using System.Text;
using RayTracer.Extensions;

namespace RayTracer.Geometry.LSystems;

/// <summary>
/// This is the base class for each of the supported renderers that will convert the
/// production of an L-system into some form of geometry.
/// </summary>
public abstract class LSystemShapeRenderer
{
    private static readonly Rune Move = new('f');
    private static readonly Rune Draw = new('F');

    /// <summary>
    /// This field holds the standard rune (character) to turtle command mapping.
    /// </summary>
    private static readonly Dictionary<Rune, TurtleCommand> StandardCommandMapping = new ()
    {
        { Move, TurtleCommand.Move },
        { Draw, TurtleCommand.DrawLine },
        { new Rune('+'), TurtleCommand.TurnLeft },
        { new Rune('-'), TurtleCommand.TurnRight },
        { new Rune('\u2212'), TurtleCommand.TurnRight },
        { new Rune('^'), TurtleCommand.PitchUp },
        { new Rune('\u2227'), TurtleCommand.PitchUp },
        { new Rune('&'), TurtleCommand.PitchDown },
        { new Rune('\\'), TurtleCommand.RollLeft },
        { new Rune('<'), TurtleCommand.RollLeft },
        { new Rune('/'), TurtleCommand.RollRight },
        { new Rune('>'), TurtleCommand.RollRight },
        { new Rune('|'), TurtleCommand.TurnAround },
        { new Rune('$'), TurtleCommand.ToVertical },
        { new Rune('['), TurtleCommand.StartBranch },
        { new Rune(']'), TurtleCommand.CompleteBranch },
        // '{' - Start a polygon.
        // 'G' - Move forward and draw a line; do not record a vertex.
        // '.' - Record a vertex in the current polygon.
        // '}' - Complete a polygon.
        // '~' - Incorporate a predefined surface.
        { new Rune('!'), TurtleCommand.DecreaseDiameter }
        // "'" - Increment color index.
        // '%' - Cut off the remainder of the branch.
    };

    /// <summary>
    /// This property returns the set of standard render command runes.
    /// </summary>
    internal static HashSet<Rune> Commands => StandardCommandMapping.Keys
        .Where(cmd => cmd != LSystemProducer.LeftBracket &&
                      cmd != LSystemProducer.RightBracket &&
                      cmd != Move && cmd != Draw)
        .ToHashSet();

    /// <summary>
    /// This property holds the set of controls that dictate how productions from this
    /// L-system are rendered into geometry.
    /// </summary>
    public LSystemRenderingControls RenderingControls { get; set; } = new ();

    /// <summary>
    /// This property holds the map that will be used to convert runes to turtle commands.
    /// </summary>
    public Dictionary<Rune, TurtleCommand> CommandMapping { get; } = new (StandardCommandMapping);

    /// <summary>
    /// This property holds the surfaces generated by a subclass.
    /// </summary>
    internal List<Surface> Surfaces { get; }

    /// <summary>
    /// This property may offer a bounding box the owning group should accept.
    /// </summary>
    internal BoundingBox BoundingBox { get; set; }

    private readonly string _production;
    private readonly Stack<Turtle> _stack;

    protected LSystemShapeRenderer(string production)
    {
        _production = production;
        _stack = new Stack<Turtle>();

        Surfaces = [];
    }

    /// <summary>
    /// This method is used to render the L-system production we were constructed with into
    /// a surface for ray tracing.
    /// </summary>
    internal void Render()
    {
        Turtle turtle = new Turtle(RenderingControls);
        
        _stack.Push(turtle);

        Begin(turtle);

        _production.AsRunes()
            .Select(ToTurtleCommand)
            .Where(command => command != TurtleCommand.Unknown)
            .ToList()
            .ForEach(command =>
            {
                PreExecute(_stack.Peek(), command);
                Execute(_stack.Peek(), command);
            });

        Complete(turtle);
    }

    /// <summary>
    /// This method is used to tell the subclass that the rendering to a surface is
    /// starting.
    /// </summary>
    /// <param name="turtle">The initial turtle.  Provided in case the renderer needs to
    /// make any initial adjustments.</param>
    protected virtual void Begin(Turtle turtle) {}

    /// <summary>
    /// This method is used to convert the given rune into a turtle command.
    /// </summary>
    /// <param name="rune">The rune to convert.</param>
    /// <returns>The turtle command the rune translates to.</returns>
    private TurtleCommand ToTurtleCommand(Rune rune)
    {
        return CommandMapping.GetValueOrDefault(rune, TurtleCommand.Unknown);
    }

    /// <summary>
    /// This method is used to provide default handling for some of the turtle commands.
    /// </summary>
    /// <param name="turtle">The current turtle.</param>
    /// <param name="command">The turtle command to handle.</param>
    private void PreExecute(Turtle turtle, TurtleCommand command)
    {
        switch (command)
        {
            case TurtleCommand.Move:
            case TurtleCommand.DrawLine:
                turtle.Move();
                break;
            case TurtleCommand.TurnLeft:
                turtle.Yaw(-1);
                break;
            case TurtleCommand.TurnRight:
                turtle.Yaw(1);
                break;
            case TurtleCommand.PitchUp:
                turtle.Pitch(1);
                break;
            case TurtleCommand.PitchDown:
                turtle.Pitch(-1);
                break;
            case TurtleCommand.RollLeft:
                turtle.Roll(-1);
                break;
            case TurtleCommand.RollRight:
                turtle.Roll(1);
                break;
            case TurtleCommand.TurnAround:
                turtle.TurnAround();
                break;
            case TurtleCommand.ToVertical:
                turtle.PointUp();
                break;
            case TurtleCommand.StartBranch:
                _stack.Push(turtle.Copy());
                break;
            case TurtleCommand.CompleteBranch:
                _stack.Pop();
                break;
            case TurtleCommand.DecreaseDiameter:
                turtle.DecreaseDiameter();
                break;
            case TurtleCommand.Unknown:
            default:
                break;
        }
    }

    /// <summary>
    /// This method should be overridden to handle the given command.
    /// </summary>
    /// <param name="turtle">The current turtle.</param>
    /// <param name="command">The turtle command to handle.</param>
    protected abstract void Execute(Turtle turtle, TurtleCommand command);

    /// <summary>
    /// This method is used to tell the subclass that the rendering to a surface is
    /// ending.
    /// </summary>
    /// <param name="turtle">The current turtle.</param>
    protected virtual void Complete(Turtle turtle) {}
}
